### ğŸ”¥ **Immutability Trap (Java) â€” à¦–à§à¦¬ à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£ à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦­à¦¿à¦‰ à¦Ÿà¦ªà¦¿à¦•**

**Immutability trap** à¦®à¦¾à¦¨à§‡ à¦à¦®à¦¨ à¦ªà¦°à¦¿à¦¸à§à¦¥à¦¿à¦¤à¦¿, à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦•à§‹à¦¡ à¦¦à§‡à¦–à§‡ à¦®à¦¨à§‡ à¦¹à§Ÿ object à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦¹à¦šà§à¦›à§‡,
à¦•à¦¿à¦¨à§à¦¤à§ **à¦†à¦¸à¦²à§‡ à¦¹à¦šà§à¦›à§‡ à¦¨à¦¾**, à¦•à¦¾à¦°à¦£ object **immutable**à¥¤

à¦¸à¦¬à¦šà§‡à§Ÿà§‡ common victim ğŸ‘‰ **`String`**

---

## ğŸ”¹ Immutable à¦®à¦¾à¦¨à§‡ à¦•à§€?

> **Object à¦¤à§ˆà¦°à¦¿ à¦¹à¦“à§Ÿà¦¾à¦° à¦ªà¦°à§‡ à¦¤à¦¾à¦° state à¦†à¦° à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦•à¦°à¦¾ à¦¯à¦¾à§Ÿ à¦¨à¦¾**

à¦¯à¦¦à¦¿ â€œà¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨â€ à¦•à¦°à¦¤à§‡ à¦šà¦¾à¦¨, Java **à¦¨à¦¤à§à¦¨ object à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡**à¥¤

---

## âš ï¸ Trap #1 â€” `String` à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦¹à¦šà§à¦›à§‡ à¦®à¦¨à§‡ à¦¹à§Ÿ, à¦•à¦¿à¦¨à§à¦¤à§ à¦¹à¦šà§à¦›à§‡ à¦¨à¦¾

```java
String s = "Java";
s.concat(" World");
System.out.println(s);
```

### â“ Output à¦•à§€?

```
Java
```

### ğŸ§  à¦•à§‡à¦¨?

* `String` immutable
* `concat()` **à¦¨à¦¤à§à¦¨ String à¦¬à¦¾à¦¨à¦¾à§Ÿ**
* à¦•à¦¿à¦¨à§à¦¤à§ result à¦•à§‹à¦¥à¦¾à¦“ assign à¦•à¦°à¦¾ à¦¹à§Ÿà¦¨à¦¿

### âœ… Correct way

```java
s = s.concat(" World");
System.out.println(s); // Java World
```

---

## âš ï¸ Trap #2 â€” Method à¦à¦° à¦­à¦¿à¦¤à¦°à§‡ String change

```java
void change(String s) {
    s = s + " World";
}

public static void main(String[] args) {
    String s = "Java";
    change(s);
    System.out.println(s);
}
```

### â“ Output

```
Java
```

### ğŸ§  Explanation

* `s` pass à¦¹à§Ÿ **value of reference**
* Method-à¦à¦° à¦­à¦¿à¦¤à¦°à§‡ `s` à¦¨à¦¤à§à¦¨ object à¦¦à§‡à¦–à¦¾à§Ÿ
* Original reference unchanged

---

## âš ï¸ Trap #3 â€” `==` à¦¦à¦¿à§Ÿà§‡ String compare

```java
String a = "Java";
String b = "Java";
String c = new String("Java");

System.out.println(a == b); // true
System.out.println(a == c); // false
```

### ğŸ§  Explanation

* `a` & `b` â†’ String pool
* `c` â†’ heap
* `==` â†’ reference compare

âœ… Always use:

```java
a.equals(c); // true
```

---

## âš ï¸ Trap #4 â€” `replace()` / `toUpperCase()`

```java
String s = "java";
s.toUpperCase();
System.out.println(s);
```

### â“ Output

```
java
```

### ğŸ§  Explanation

* `toUpperCase()` à¦¨à¦¤à§à¦¨ String à¦¬à¦¾à¦¨à¦¾à§Ÿ
* à¦ªà§à¦°à§‹à¦¨à§‹ `s` unchanged

âœ… Correct:

```java
s = s.toUpperCase();
```

---

## âš ï¸ Trap #5 â€” StringBuilder vs String

```java
String s = "Java";
s = s + " World";  // new object each time âŒ (slow in loop)
```

Loop à¦ à¦à¦Ÿà¦¾ à¦•à¦°à¦²à§‡:

* à¦…à¦¨à§‡à¦• object
* GC pressure
* Performance drop

### âœ… Correct tool

```java
StringBuilder sb = new StringBuilder("Java");
sb.append(" World");
```

---

## ğŸ” Why String is Immutable? (Interview Question)

âœ” Thread-safe
âœ” String pool possible
âœ” Security (classloader, DB URL, file path)
âœ” HashMap key safety

---

## ğŸ§  Interview One-Liner (Perfect)

> **â€œString is immutable, so methods like concat, replace, toUpperCase do not modify the original object; they return a new oneâ€”failing to reassign causes immutability traps.â€**

---

## ğŸ“Œ Quick Summary Table

| Operation                | Original String changes? |
| ------------------------ | ------------------------ |
| `concat()`               | âŒ No                     |
| `replace()`              | âŒ No                     |
| `toUpperCase()`          | âŒ No                     |
| `+` operator             | âŒ No (new object)        |
| `StringBuilder.append()` | âœ… Yes                    |

---

If you want next:

* ğŸ”¥ **Real interview MCQs on immutability**
* âš ï¸ **HashMap + immutable key trap**
* ğŸ§ª **Why wrapper classes are immutable**
* ğŸš€ **Deep dive: JVM & String pool**

Just say ğŸ‘
