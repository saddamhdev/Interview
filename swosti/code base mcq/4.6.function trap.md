‡¶è‡¶á‡¶ü‡¶æ **classic index trap / function trap** ‚Äî ‡¶ñ‡ßÅ‡¶¨ ‡¶≠‡¶æ‡¶≤‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® üëç
‡¶ö‡¶≤ step-by-step ‡¶¶‡ßá‡¶ñ‡¶ø **‡¶ï‡ßá‡¶® index ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ** ‡¶Ü‡¶∞ **‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º**‡•§

---

## ‚ùå Query ‡¶ü‡¶æ ‡¶ï‡ßá‡¶® slow ‡¶π‡¶¨‡ßá?

```sql
SELECT * FROM users WHERE id + 1 = 100;
```

‡¶ß‡¶∞‡¶ø:

* `id` column-‡¶è **B-Tree index ‡¶Ü‡¶õ‡ßá**
* `id` ‡¶π‡¶≤‡ßã primary key

### üî¥ Problem (Index Trap)

PostgreSQL ‡¶è‡¶á condition ‡¶ü‡¶æ ‡¶è‡¶Æ‡¶®‡¶≠‡¶æ‡¶¨‡ßá ‡¶¶‡ßá‡¶ñ‡ßá:

```text
(id + 1) = 100
```

üëâ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá **column-‡¶è‡¶∞ ‡¶ì‡¶™‡¶∞ arithmetic function** (`+ 1`) ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
üëâ Index ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ raw column value (`id`) ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã
üëâ ‡¶§‡¶æ‡¶á **index ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶®‡¶æ**

üìå DB ‡¶ï‡ßá ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶Ø‡¶º:

* ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ row ‡¶è‡¶∞ `id`
* ‡¶§‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá `+1`
* ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ compare

‚û°Ô∏è Result: **Seq Scan (Full Table Scan)**

---

## üîç Proof (EXPLAIN)

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE id + 1 = 100;
```

‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü ‡¶π‡¶¨‡ßá ‡¶è‡¶Æ‡¶® ‡¶ï‡¶ø‡¶õ‡ßÅ:

```
Seq Scan on users
```

‚ùå Index ignored

---

## ‚úÖ Correct Way (Index-friendly)

### üîπ Algebra apply ‡¶ï‡¶∞‡ßã (column left side ‡¶è ‡¶∞‡¶æ‡¶ñ‡ßã)

```sql
SELECT * FROM users WHERE id = 99;
```

‚úîÔ∏è Same logic
‚úîÔ∏è Index usable
‚úîÔ∏è O(log n)

üìå Rule:

> **Column must appear ‚Äúas-is‚Äù on one side of comparison**

---

## üîÅ General Rule (Golden Rule üî•)

‚ùå Bad (index breaks):

```sql
WHERE column + 1 = 100
WHERE LOWER(email) = 'a@b.com'
WHERE DATE(created_at) = '2025-01-01'
```

‚úÖ Good:

```sql
WHERE column = 99
WHERE email = 'a@b.com'
WHERE created_at >= '2025-01-01'
  AND created_at <  '2025-01-02'
```

---

## üõ†Ô∏è Advanced Option: Functional Index (If unavoidable)

‡¶Ø‡¶¶‡¶ø ‡¶∏‡¶§‡ßç‡¶Ø‡¶ø‡¶á ‡¶è‡¶Æ‡¶® query ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶Ø‡¶º:

```sql
CREATE INDEX idx_users_id_plus1 ON users ((id + 1));
```

‡¶§‡¶æ‡¶∞‡¶™‡¶∞:

```sql
SELECT * FROM users WHERE id + 1 = 100;
```

‚úîÔ∏è Index used
‚ö†Ô∏è Rarely recommended (design smell)

---

## üß† Interview One-liner

> **Indexes are used only when the column appears directly in the predicate. Applying functions or arithmetic on indexed columns prevents index usage unless a functional index exists.**

---

## üéØ Real-World Best Practice

* Column-‡¶è function ‡¶≤‡¶æ‡¶ó‡¶æ‡¶¨‡ßá ‡¶®‡¶æ
* Value transform ‡¶ï‡¶∞‡ßã, column ‡¶®‡¶æ
* `EXPLAIN ANALYZE` ‡¶õ‡¶æ‡¶°‡¶º‡¶æ performance trust ‡¶ï‡¶∞‡ßã ‡¶®‡¶æ

---

‡¶ö‡¶æ‡¶ì ‡¶§‡ßã ‡¶Ü‡¶Æ‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø:

* `DATE(col)` vs range query
* JPA/Hibernate ‡¶è ‡¶è‡¶á trap ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡ßü
* Functional index ‡¶ï‡¶ñ‡¶® justified
* Query rewrite patterns (cheat-sheet)

‡¶¨‡¶≤‡¶≤‡ßá‡¶á ‡¶ö‡¶≤‡¶¨‡ßá üöÄ
