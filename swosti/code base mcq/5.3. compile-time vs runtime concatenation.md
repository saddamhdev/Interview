Great! Let me explain **compile-time vs runtime concatenation** with real scenarios.

---

## **1Ô∏è‚É£ COMPILE-TIME CONCATENATION**

**Scenario: All strings are LITERALS (constants)**

```java
String a = "Hello" + " " + "World";
String b = "Hello World";
System.out.println(a == b);  // true
```

**What happens:**
- Compiler sees only **string literals** (fixed values)
- Combines them **before the program runs**
- Creates only **ONE object** in String pool

```
Compile-time:
"Hello" + " " + "World" ‚Üí "Hello World"

Result:
a ‚Üí ["Hello World"] ‚Üê b (same object)
```

**Real Example:**
```java
// All compile-time (no variables)
String fullName = "John" + " " + "Doe";
String message = "Welcome" + "!";
String url = "https://" + "example.com" + "/page";
```

---

## **2Ô∏è‚É£ RUNTIME CONCATENATION**

**Scenario: At least ONE variable is involved**

```java
String firstName = "John";    // Variable
String lastName = "Doe";      // Variable
String fullName = firstName + " " + lastName;  // Runtime concat
System.out.println(fullName == "John Doe");   // false
```

**What happens:**
- Compiler **cannot predict** the values (they're variables)
- Java creates a **new String object at runtime** using `StringBuilder`
- Creates a **different object** in heap memory

```
Runtime:
firstName = "John"
lastName = "Doe"
fullName = firstName + " " + lastName
         ‚Üí NEW StringBuilder ‚Üí NEW String object

Result:
"John Doe" (String pool) ‚Üê different reference
fullName ‚Üí "John Doe" (heap memory) ‚Üê different location
```

---

## **Real-World Scenarios:**

### **Scenario 1: Compile-time ‚úÖ**

```java
// User registration form
String greeting = "Welcome" + ", " + "User!";
String email = "contact" + "@" + "company.com";

// Another same value
String same = "Welcome, User!";
System.out.println(greeting == same);  // true ‚úì
```

**Why?** Only literals used.

---

### **Scenario 2: Runtime ‚ùå**

```java
// Get data from database
String userName = getUserName();  // "John" (from database)
String greeting = "Welcome, " + userName;

String staticGreeting = "Welcome, John";
System.out.println(greeting == staticGreeting);  // false ‚ùå
```

**Why?** Variable involved, runtime concat creates new object.

---

### **Scenario 3: User Input ‚ùå**

```java
// User enters name in form
Scanner sc = new Scanner(System.in);
String userInput = sc.nextLine();  // Runtime variable

String message = "Hello, " + userInput;  // Runtime concat
System.out.println(message == "Hello, John");  // false
```

**Why?** Input is unpredictable, concat happens at runtime.

---

### **Scenario 4: Loop Concatenation ‚ùå**

```java
String result = "";
for(int i = 1; i <= 3; i++) {
    result = result + i;  // Runtime concat each iteration
}
System.out.println(result);  // "123"
System.out.println(result == "123");  // false ‚ùå (new object created)
```

**Why?** Each iteration creates new String object.

---

## **Quick Comparison Table:**

| Scenario | Code | Type | Same Object? |
|----------|------|------|--------------|
| **Literals only** | `"Hello" + "World"` | Compile-time | ‚úÖ YES |
| **1 Variable** | `str + "World"` | Runtime | ‚ùå NO |
| **Both Variables** | `str1 + str2` | Runtime | ‚ùå NO |
| **From user input** | `input + "!"` | Runtime | ‚ùå NO |
| **From loop** | `result += i` | Runtime | ‚ùå NO |
| **Method result** | `getName() + "!"` | Runtime | ‚ùå NO |

---

## **Best Practice:**

```java
// ‚ùå DON'T (uses == for String comparison)
if (result == "123") { }

// ‚úÖ DO (use .equals())
if (result.equals("123")) { }

// ‚úÖ BEST (for efficiency with loops)
StringBuilder sb = new StringBuilder();
for(int i = 1; i <= 3; i++) {
    sb.append(i);
}
String result = sb.toString();
```

---

## **Summary:**

| Type | When | How | Performance |
|------|------|-----|-------------|
| **Compile-time** | Only literals | Optimized by compiler | ‚ö° Fast |
| **Runtime** | Variables involved | New StringBuilder each time | üê¢ Slower |

**Key Rule:** Always use `.equals()` for String comparison! üëç
