### **Static Method & Inheritance (Method Hiding)**

*(Java â€“ clear concept + interview-ready)*

---

## ğŸ”¹ Static Method à¦•à§€?

* `static` method **class-level**
* Object-à¦à¦° à¦¸à¦¾à¦¥à§‡ bind à¦¹à§Ÿ à¦¨à¦¾
* **Compile-time binding** à¦¹à§Ÿ

```java
class A {
    static void show() {
        System.out.println("A");
    }
}
```

---

## ğŸ”¹ Inheritance à¦ Static Method à¦•à§€à¦­à¦¾à¦¬à§‡ à¦•à¦¾à¦œ à¦•à¦°à§‡?

ğŸ‘‰ **Static methods override à¦¹à§Ÿ à¦¨à¦¾**
ğŸ‘‰ à¦à¦—à§à¦²à§‹ **method hiding** à¦•à¦°à§‡

> **Method Hiding** = child class à¦à¦•à¦‡ signature à¦¦à¦¿à§Ÿà§‡ static method à¦²à¦¿à¦–à¦²à§‡ parent-à¦à¦° method **hide** à¦¹à§Ÿ, override à¦¨à¦¾à¥¤

---

## ğŸ”¹ Example (Method Hiding)

```java
class A {
    static void show() {
        System.out.print("A");
    }
}

class B extends A {
    static void show() {
        System.out.print("B");
    }
}

public class Test {
    public static void main(String[] args) {
        A obj = new B();
        obj.show();
    }
}
```

### âœ… Output:

```
A
```

---

## ğŸ§  à¦•à§‡à¦¨ Output â€œAâ€?

### Step-by-step:

1. `obj` reference type = `A`
2. `show()` is **static**
3. Static methods â†’ **compile-time binding**
4. Compiler à¦¦à§‡à¦–à§‡:

   ```java
   A obj;
   obj.show();  // â†’ A.show()
   ```
5. à¦¤à¦¾à¦‡ `A.show()` call à¦¹à§Ÿ

---

## ğŸ”¥ Key Rule (Interview Gold)

> **Static methods are resolved by reference type, not object type.**

---

## ğŸ” Static vs Instance Method Comparison

| Feature              | Static Method     | Instance Method   |
| -------------------- | ----------------- | ----------------- |
| Binding              | Compile-time      | Runtime           |
| Polymorphism         | âŒ No              | âœ… Yes             |
| Override             | âŒ Not allowed     | âœ… Allowed         |
| Inheritance behavior | Method hiding     | Method overriding |
| Called by            | Class / reference | Object            |

---

## ğŸ”„ Compare with Instance Method (Override)

```java
class A {
    void show() {
        System.out.print("A");
    }
}

class B extends A {
    void show() {
        System.out.print("B");
    }
}

A obj = new B();
obj.show();
```

### âœ… Output:

```
B
```

âœ” Runtime polymorphism

---

## âš ï¸ Illegal Combinations (Compile-time Error)

### âŒ Static â†’ Non-static

```java
class B extends A {
    void show() {}   // âŒ Error
}
```

### âŒ Non-static â†’ Static

```java
class B extends A {
    static void show() {}  // âŒ Error
}
```

ğŸ‘‰ Method signature must keep `static` consistency

---

## ğŸ§  One-Line Interview Answer

> **â€œStatic methods are not overridden, they are hidden. Method call depends on reference type because static binding happens at compile time.â€**

---

If you want next:

* ğŸ”¥ Static blocks & initialization order
* âš ï¸ Method hiding MCQs
* ğŸ§ª JVM bytecode behavior
* ğŸš€ Advanced polymorphism traps
