ржЪржорзОржХрж╛рж░ ржкрзНрж░рж╢рзНржи ЁЯСН
**тАЬdifferent type of complexity countтАЭ** ржорж╛ржирзЗ рж╕рж╛ржзрж╛рж░ржгржд **Algorithm Complexity Analysis**тАУржП ржЖржорж░рж╛ ржХрзА ржХрзА ржзрж░ржирзЗрж░ **complexity** ржЧржгржирж╛ (count) ржХрж░рж┐тАФржПржЯрж╛ржЗ ржмрзЛржЭрж╛рзЯред

ржЖржорж┐ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ, **example + intuition + interview view** рж╕рж╣ ржмрзБржЭрж╛ржЪрзНржЫрж┐ред

---

# ЁЯФ╖ Algorithm Complexity тАУ Different Types of Complexity Count

Algorithm ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗ ржорзВрж▓ржд ржЖржорж░рж╛ **рзиржЯрж╛ ржмрзЬ ржЬрж┐ржирж┐рж╕** ржжрзЗржЦрж┐:

1. **Time Complexity** (рж╕ржорзЯ ржХржд рж▓рж╛ржЧржмрзЗ)
2. **Space Complexity** (ржорзЗржорзЛрж░рж┐ ржХржд рж▓рж╛ржЧржмрзЗ)

ржПрж░ ржнрж┐рждрж░рзЗ ржЖржмрж╛рж░ **ржнрж┐ржирзНржи ржнрж┐ржирзНржи ржзрж░ржи** ржЖржЫрзЗред

---

## 1я╕ПтГг Time Complexity (рж╕ржорзЯрзЗрж░ рж╣рж┐рж╕рж╛ржм)

Time Complexity ржмрзЛржЭрж╛рзЯ:

> **Input size ржмрж╛рзЬрж▓рзЗ algorithm ржХрждржмрж╛рж░ operation ржХрж░ржЫрзЗ**

### ЁЯФ╣ ржХрзА тАЬcountтАЭ ржХрж░рж╛ рж╣рзЯ?

* Loop ржХрзЯржмрж╛рж░ ржШрзБрж░ржЫрзЗ
* Comparison ржХрзЯржмрж╛рж░ рж╣ржЪрзНржЫрзЗ
* Function call ржХрзЯржмрж╛рж░ рж╣ржЪрзНржЫрзЗ

ЁЯСЙ ржЖржорж░рж╛ **exact time ржирзЯ**, ржмрж░ржВ **growth rate** ржжрзЗржЦрж┐ред

---

### ЁЯФ╕ a) Constant Time тАФ `O(1)`

ржЗржиржкрзБржЯ ржпржд ржмрзЬржЗ рж╣рзЛржХ, ржХрж╛ржЬрзЗрж░ рж╕ржВржЦрзНржпрж╛ ржПржХржЗред

```java
int x = arr[0];
```

тЬФ рж╕ржмрж╕ржорзЯ рззржЯрж╛ operation

---

### ЁЯФ╕ b) Linear Time тАФ `O(n)`

ржЗржиржкрзБржЯ ржмрж╛рзЬрж▓рзЗ ржХрж╛ржЬржУ рж╕рж░рж▓ржнрж╛ржмрзЗ ржмрж╛рзЬрзЗред

```java
for(int i = 0; i < n; i++) {
    System.out.println(i);
}
```

тЬФ `n` ржмрж╛рж░ ржХрж╛ржЬ

---

### ЁЯФ╕ c) Logarithmic Time тАФ `O(log n)`

ржкрзНрж░рждрж┐ ржзрж╛ржкрзЗ ржХрж╛ржЬ **ржЕрж░рзНржзрзЗржХ / ржжрзНржмрж┐ржЧрзБржг** рж╣рзЯред

```java
for(int i = 1; i < n; i *= 2) {
    System.out.println(i);
}
```

тЬФ Binary search ржПрж░ ржорждрзЛ

---

### ЁЯФ╕ d) Linearithmic тАФ `O(n log n)`

ржПржХржЯрж╛ `log n` ржХрж╛ржЬ `n` ржмрж╛рж░ рж╣ржЪрзНржЫрзЗред

```java
for(int i = 0; i < n; i++) {
    binarySearch();
}
```

тЬФ Merge sort, quick sort (avg case)

---

### ЁЯФ╕ e) Quadratic тАФ `O(n┬▓)`

Nested loop

```java
for(int i = 0; i < n; i++)
    for(int j = 0; j < n; j++)
        ...
```

---

### ЁЯФ╕ f) Cubic тАФ `O(n┬│)`

Triple nested loop
(rare, but exists)

---

### ЁЯФ╕ g) Exponential тАФ `O(2тБ┐)`

ржкрзНрж░рждрж┐ржЯрж╛ element-ржПрж░ ржЬржирзНржп ржжрзБржЗржЯрж╛ possibility

```java
f(n) = f(n-1) + f(n-1);
```

тЬФ Fibonacci (naive recursion)

---

### ЁЯФ╕ h) Factorial тАФ `O(n!)`

Permutation based problems

---

## 2я╕ПтГг Best, Average, Worst Case Complexity

### ЁЯФ╣ Best Case

рж╕ржмржЪрзЗрзЯрзЗ ржнрж╛рж▓рзЛ ржкрж░рж┐рж╕рзНржерж┐рждрж┐

```java
search element at index 0
```

---

### ЁЯФ╣ Worst Case

рж╕ржмржЪрзЗрзЯрзЗ ржЦрж╛рж░рж╛ржк ржкрж░рж┐рж╕рзНржерж┐рждрж┐ (ржЗржирзНржЯрж╛рж░ржнрж┐ржЙрждрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЗрж╢рж┐ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг)

```java
element not found
```

---

### ЁЯФ╣ Average Case

рж╕ржм ржЗржиржкрзБржЯрзЗрж░ ржЧрзЬ рж╕ржорзЯ

---

## 3я╕ПтГг Space Complexity (ржорзЗржорзЛрж░рж┐рж░ рж╣рж┐рж╕рж╛ржм)

Space Complexity ржорж╛ржирзЗ:

> **Algorithm ржЪрж╛рж▓рж╛рждрзЗ extra memory ржХржд рж▓рж╛ржЧрзЗ**

---

### ЁЯФ╣ a) Constant Space тАФ `O(1)`

```java
int a, b, c;
```

---

### ЁЯФ╣ b) Linear Space тАФ `O(n)`

```java
int[] arr = new int[n];
```

---

### ЁЯФ╣ c) Recursive Space тАФ Call Stack

```java
void f(int n) {
    if(n == 0) return;
    f(n - 1);
}
```

тЬФ Stack space = `O(n)`

---

## 4я╕ПтГг Auxiliary Space (Extra Memory)

Auxiliary space =

> **Input ржмрж╛ржж ржжрж┐рзЯрзЗ algorithm ржирж┐ржЬрзЗ ржХржд extra memory ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрзЗ**

Example:

```java
int[] temp = new int[n];
```

Auxiliary space = `O(n)`

---

## 5я╕ПтГг Amortized Complexity (ржЧрзЬ рж╣рж┐рж╕рж╛ржм)

ржХрж┐ржЫрзБ operation ржорж╛ржЭрзЗ ржорж╛ржЭрзЗ expensive, ржХрж┐ржирзНрждрзБ ржЧрзЬрзЗ cheapред

### Example: `ArrayList.add()`

* ржорж╛ржЭрзЗ ржорж╛ржЭрзЗ resize тЖТ costly
* ржХрж┐ржирзНрждрзБ ржЧрзЬрзЗ тЖТ `O(1)`

ЁЯСЙ **Amortized O(1)**

---

## 6я╕ПтГг Big-O, Big-╬й, Big-╬Ш (Notation types)

| Notation | ржорж╛ржирзЗ                       |
| -------- | -------------------------- |
| Big-O    | Upper bound (Worst case)   |
| Big-╬й    | Lower bound (Best case)    |
| Big-╬Ш    | Tight bound (Exact growth) |

---

## 7я╕ПтГг Common Interview Trick тЪая╕П

```java
for(int i = 0; i < n; i += 2)
```

ЁЯСЙ Still `O(n)` (constant ignored)

```java
for(int i = n; i > 1; i /= 2)
```

ЁЯСЙ `O(log n)`

---

## ЁЯза Interview One-Liner

> **тАЬComplexity count measures how an algorithmтАЩs time and space grow with input size, typically expressed using Big-O notation.тАЭ**

---

## ЁЯУМ Quick Summary Table

| Type        | Complexity          |
| ----------- | ------------------- |
| Constant    | O(1)                |
| Linear      | O(n)                |
| Logarithmic | O(log n)            |
| Quadratic   | O(n┬▓)               |
| Exponential | O(2тБ┐)               |
| Space       | O(1), O(n)          |
| Amortized   | Avg over operations |

---

ржЪрж╛ржУ рждрзЛ ржЖржорж┐ ржкрж░рзЗрж░ ржзрж╛ржкрзЗ ржжрж┐рждрзЗ ржкрж╛рж░рж┐:

* ЁЯФе Complexity MCQs
* тЪая╕П Loop counting tricks
* ЁЯзк Recursive complexity patterns
* ЁЯЪА DSA interview cheat sheet
