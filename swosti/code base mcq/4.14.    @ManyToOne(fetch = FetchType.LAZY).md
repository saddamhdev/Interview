No problem ЁЯСН тАФ ржЪрж▓ **ржПржХржжржо рж╕рж╣ржЬ ржнрж╛рж╖рж╛рзЯ**, step-by-step ржмрзБржЭрж┐ред
ржнрж╛ржмрзЛ рждрзБржорж┐ **real life**-ржП ржЖржЫрзЛред

---

## 1я╕ПтГг Situation (Real life example)

ржзрж░рж┐:

* **User** = ржмрж╛ржмрж╛
* **Order** = ржмрж╛ржмрж╛рж░ рж╕ржирзНрждрж╛ржирзЗрж░рж╛

ЁЯСЙ ржЕржирзЗржХ `Order`-ржПрж░ **ржПржХржЬржиржЗ User** ржерж╛ржХрзЗ

```text
Order тЖТ User
```

---

## 2я╕ПтГг Code ржЯрж╛ ржХрзА ржмрж▓ржЫрзЗ?

```java
@ManyToOne(fetch = FetchType.LAZY)
private User user;
```

ржПрж░ ржорж╛ржирзЗ:

> **Order load рж╣рж▓рзЗ рж╕рж╛ржерзЗ рж╕рж╛ржерзЗ User ржЖржиржмрзЗ ржирж╛**
> User рждржЦржиржЗ ржЖржиржмрзЗ, **ржпржЦржи рждрзБржорж┐ `order.getUser()` ржбрж╛ржХржмрзЗ**

---

## 3я╕ПтГг Without LAZY (Default EAGER) тЭМ

ржпржжрж┐ рждрзБржорж┐ ржПржЯрж╛ рж▓рзЗржЦрзЛ:

```java
@ManyToOne
private User user;
```

рждрж╛рж╣рж▓рзЗ ржХрзА рж╣ржмрзЗ?

```java
Order order = orderRepo.findById(1L);
```

ЁЯСЙ DB query рж╣ржмрзЗ ржПржоржи:

```sql
SELECT o.*, u.*
FROM orders o
JOIN users u ON o.user_id = u.id;
```

тЭМ User ржжрж░ржХрж╛рж░ рж╣рзЛржХ ржмрж╛ ржирж╛ рж╣рзЛржХ тАФ DB ржерзЗржХрзЗ ржЪрж▓рзЗ ржЖрж╕ржмрзЗ
тЭМ ржЕржирзЗржХ order ржерж╛ржХрж▓рзЗ тЖТ performance рж╕ржорж╕рзНржпрж╛

---

## 4я╕ПтГг With LAZY (Correct way) тЬЕ

```java
@ManyToOne(fetch = FetchType.LAZY)
private User user;
```

ржПржЦржи:

```java
Order order = orderRepo.findById(1L);
```

ЁЯСЙ рж╢рзБржзрзБ order ржЖрж╕ржмрзЗ

```sql
SELECT * FROM orders WHERE id = 1;
```

ржПржЦржи ржпржжрж┐ рждрзБржорж┐ ржПржЯрж╛ ржХрж░рзЛ:

```java
order.getUser();
```

рждржЦржиржЗ DB query рж╣ржмрзЗ:

```sql
SELECT * FROM users WHERE id = ?;
```

тЮбя╕П **ржжрж░ржХрж╛рж░ ржирж╛ рж╣рж▓рзЗ User ржЖржиржЫрзЗржЗ ржирж╛** ЁЯСН

---

## 5я╕ПтГг One sentence to remember ЁЯза

> **LAZY ржорж╛ржирзЗ = тАЬржПржЦржи ржирж╛, ржжрж░ржХрж╛рж░ рж╣рж▓рзЗ ржкрж░рзЗтАЭ**

---

## 6я╕ПтГг Very common confusion (IMPORTANT тЪая╕П)

```java
Order order = service.getOrder(); // transaction рж╢рзЗрж╖
order.getUser(); // тЭМ crash
```

ЁЯСЙ Error ржЖрж╕ржмрзЗ: `LazyInitializationException`

### ржХрзЗржи?

* Transaction рж╢рзЗрж╖
* DB connection ржмржирзНржз
* ржПржЦржи ржЖрж░ User ржЖржирждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛

---

## 7я╕ПтГг Safe way (Beginner-friendly)

### тЬФя╕П Service layer-ржП access ржХрж░рзЛ

```java
@Transactional
public OrderDTO getOrder(Long id) {
    Order o = repo.findById(id).get();
    return new OrderDTO(o.getId(), o.getUser().getName());
}
```

---

## 8я╕ПтГг Very short Interview Answer ЁЯОп

> **`@ManyToOne(fetch = LAZY)` means the parent entity is loaded only when it is accessed, not when the child entity is fetched.**

---

## 9я╕ПтГг One-line summary (memorize this)

> **EAGER = ржПржЦржиржЗ ржЖржирзЛ**
> **LAZY = ржкрж░рзЗ ржЖржирзЛ, ржжрж░ржХрж╛рж░ рж╣рж▓рзЗ**

---

ржпржжрж┐ рждрзБржорж┐ ржЪрж╛ржУ, ржЖржорж┐ **diagram ржПржБржХрзЗ**, ржмрж╛ **real SQL ржжрзЗржЦрж┐рзЯрзЗ**, ржмрж╛ **one tiny example project** ржмрж╛ржирж┐рзЯрзЗ ржжрзЗржЦрж╛рждрзЗ ржкрж╛рж░рж┐ред
ржмрж▓рж▓рзЗржЗ ржЖржорж┐ рждрзЛржорж╛рж░ style-ржП ржмрзБржЭрж╛ржмрзЛ ЁЯШК
