Hereâ€™s a **clear, Java-interviewâ€“ready explanation** of **`int` vs `Integer`**, with **examples, traps, and best practices**.

---

# `int` vs `Integer` in Java

## 1ï¸âƒ£ What they are

| Feature               | `int`           | `Integer`                               |
| --------------------- | --------------- | --------------------------------------- |
| Type                  | **Primitive**   | **Wrapper class** (`java.lang.Integer`) |
| Stored in             | Stack (usually) | Heap (object)                           |
| Default value (field) | `0`             | `null`                                  |
| Can be `null`         | âŒ No            | âœ… Yes                                   |
| Methods available     | âŒ No            | âœ… Yes (`parseInt`, `valueOf`, etc.)     |
| Used in collections   | âŒ No            | âœ… Yes (`List<Integer>`)                 |

---

## 2ï¸âƒ£ Basic example

```java
int a = 10;
Integer b = 10;

System.out.println(a); // 10
System.out.println(b); // 10
```

Looks similar â€” **but they behave differently**.

---

## 3ï¸âƒ£ Comparison behavior (`==` vs `equals()`)

### `int` comparison (value-based)

```java
int a = 100;
int b = 100;
System.out.println(a == b); // true
```

âœ” Always compares **values**

---

### `Integer` comparison (reference-based with `==`)

```java
Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false
```

âŒ `==` compares **references**, not values

âœ… Correct way:

```java
System.out.println(a.equals(b)); // true
```

---

## 4ï¸âƒ£ Integer Cache (VERY IMPORTANT)

Java caches `Integer` objects from **-128 to 127**.

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true (cached)

Integer x = 128;
Integer y = 128;
System.out.println(x == y); // false (new objects)
```

âš ï¸ **Never rely on `==` for `Integer`**

---

## 5ï¸âƒ£ Autoboxing & Unboxing

### Autoboxing

```java
Integer a = 10; // int â†’ Integer
```

### Unboxing

```java
int b = a; // Integer â†’ int
```

---

## 6ï¸âƒ£ Dangerous NPE trap (very common)

```java
Integer a = null;
int b = a; // âŒ NullPointerException
```

Why?

* Java tries to **unbox `null`** â†’ crash

âœ… Safe check:

```java
if (a != null) {
    int b = a;
}
```

---

## 7ï¸âƒ£ Performance difference

| Aspect      | `int`  | `Integer`                |
| ----------- | ------ | ------------------------ |
| Memory      | Less   | More (object overhead)   |
| Speed       | Faster | Slower (boxing/unboxing) |
| GC pressure | None   | Yes                      |

ğŸ‘‰ **Use `int` for performance-critical code**

---

## 8ï¸âƒ£ Collections & Generics

Java collections **cannot store primitives**.

âŒ Invalid:

```java
List<int> list = new ArrayList<>();
```

âœ… Valid:

```java
List<Integer> list = new ArrayList<>();
```

---

## 9ï¸âƒ£ When to use what (BEST PRACTICE)

### âœ… Use `int` when:

* Value is **mandatory**
* Performance matters
* No `null` needed
* Loops, counters, calculations

### âœ… Use `Integer` when:

* Value can be **null**
* Working with **collections**
* Using **frameworks** (Hibernate, Spring, JSON)
* Need **object methods**

---

## ğŸ”¥ Interview Trick Questions

### Q1

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);
```

âœ… **true** (cached)

---

### Q2

```java
Integer a = 100;
int b = 100;
System.out.println(a == b);
```

âœ… **true** (unboxing â†’ int comparison)

---

### Q3

```java
Integer a = null;
if (a == 0) {}
```

âŒ **NullPointerException**

---

## ğŸ§  Final One-Line Interview Answer

> **â€œ`int` is a primitive, faster and cannot be null. `Integer` is an object, supports null and collections, but `==` compares references and may cause NPE due to unboxing.â€**

---

If you want next:

* âœ… **`String` vs `StringBuilder` vs `StringBuffer`**
* âœ… **Autoboxing pitfalls**
* âœ… **JVM memory diagram**
* âœ… **MCQs on wrappers**

Just tell me ğŸ‘
