рж╣рзНржпрж╛ржБ тЬЕ **exactly тАФ `orphanRemoval = true` рж▓рж╛ржЧржмрзЗ** ЁЯСН

---

## тЬЕ Final Correct Mapping (Child remove ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ)

```java
@OneToMany(
    mappedBy = "user",
    cascade = CascadeType.ALL,
    orphanRemoval = true
)
private List<Order> orders;
```

---

## ЁЯФН ржПржЦржи ржХрзА рж╣ржмрзЗ?

```java
user.getOrders().remove(order);
```

тЮбя╕П Hibernate ржмрзБржЭржмрзЗ:

> тАЬржПржЗ `Order` ржЖрж░ ржХрзЛржирзЛ `User`-ржПрж░ child ржирж╛ тЖТ ржПржЯрж╛ржХрзЗ DB ржерзЗржХрзЗржУ delete ржХрж░рждрзЗ рж╣ржмрзЗтАЭ

тЬФя╕П **Row delete рж╣ржмрзЗ database ржерзЗржХрзЗ**

---

## тЭМ Without `orphanRemoval = true`

```java
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
```

```java
user.getOrders().remove(order);
```

тЭМ Child DB ржерзЗржХрзЗ delete **рж╣ржмрзЗ ржирж╛**
тЭМ рж╢рзБржзрзБ relationship ржнрж╛ржЩрждрзЗ ржкрж╛рж░рзЗ (`user_id = NULL`)
тЭМ ржЕржержмрж╛ ржХрж┐ржЫрзБржЗ ржирж╛ржУ рж╣рждрзЗ ржкрж╛рж░рзЗ

---

## ЁЯза Remember This Rule (Interview Gold ЁЯПЖ)

> **CascadeType.REMOVE тЙа orphanRemoval**
>
> * Cascade тЖТ parent action propagate
> * OrphanRemoval тЖТ child ownership enforce

---

## ЁЯЫбя╕П Best Practice (Production Safe)

```java
@OneToMany(
    mappedBy = "user",
    cascade = {CascadeType.PERSIST, CascadeType.MERGE},
    orphanRemoval = true
)
```

тЬФя╕П Accidental mass delete ржПржбрж╝рж╛ржирзЛ ржпрж╛ржпрж╝
тЬФя╕П Child remove fully controlled

---

## ЁЯОп One-line Answer

> **Yes тАФ to delete a child entity when it is removed from the parent collection, `orphanRemoval = true` is required.**

ржЪрж╛ржУ рждрзЛ ржЖржорж┐ next ржП ржжрзЗржЦрж╛рждрзЗ ржкрж╛рж░рж┐:

* Hibernate ржХрзА SQL generate ржХрж░рзЗ
* FK nullable vs not-null behavior
* Soft delete alternative
* Real bug examples

ржмрж▓рж▓рзЗржЗ рж╢рзБрж░рзБ ржХрж░рж┐ ЁЯСН
