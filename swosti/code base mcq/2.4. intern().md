### ‚ùì Question ‚Äî `String.intern()` behavior

```java
String s1 = "Java";
String s2 = new String("Java").intern();
System.out.println(s1 == s2);
```

### ‚úÖ **Output: `true`**

---

## üß† Why? (Step-by-step)

### 1Ô∏è‚É£ String literal goes to **String Pool**

```java
String s1 = "Java";
```

* `"Java"` is a **string literal**
* JVM places it in the **String Constant Pool**
* `s1` **references the pooled object**

---

### 2Ô∏è‚É£ `new String("Java")` creates a **new heap object**

```java
new String("Java")
```

* A **separate object** is created on the heap
* It is **not** the pooled one

---

### 3Ô∏è‚É£ `.intern()` returns the **pooled reference**

```java
String s2 = new String("Java").intern();
```

* `intern()` checks the String Pool:

  * If `"Java"` **exists**, return its pooled reference
  * If not, add it and return that
* Since `"Java"` already exists (from `s1`), `intern()` returns **the same reference as `s1`**

---

### 4Ô∏è‚É£ `==` compares **references**

```java
System.out.println(s1 == s2);
```

* Both `s1` and `s2` now reference **the same pooled object**
* Therefore ‚Üí **`true`**

---

## üîç Visual Summary

```
String Pool:
  "Java"  ‚Üê‚îÄ‚îÄ s1
            ‚Üë
            ‚îî‚îÄ‚îÄ s2 (after intern())
```

---

## ‚ö†Ô∏è Common Traps (Interview Gold)

### Trap 1: Without `intern()`

```java
String s1 = "Java";
String s2 = new String("Java");
System.out.println(s1 == s2); // false
```

* Different objects ‚Üí different references

### Trap 2: `equals()` vs `==`

```java
s1.equals(s2); // true (value comparison)
s1 == s2;      // depends on pooling/intern()
```

---

## üß† One-Line Interview Answer

> **‚Äú`intern()` returns the canonical pooled string, so both references point to the same object; hence `==` returns true.‚Äù**

If you want:

* `intern()` performance implications
* Java 7+ String Pool changes
* More string pool MCQs
* Real-world pitfalls with `intern()`
