Excellent! Let me explain **Right Shift Operator (`>>`)**!

---

## **Right Shift (`>>`)**

**`>>` shifts all bits to the RIGHT by specified positions, filling with the sign bit (0 or 1) on the left.**

**Formula:**
```
a >> n  =  a ÷ 2^n  (integer division)
```

---

## **Step-by-Step Example:**

### **Example 1: Positive Number**

```java
int a = 16;
System.out.println(a >> 2);
```

**Output: 4** ✅

---

### **Step 1: Initial Value**

```
a = 16

Binary representation (32-bit):
0000 0000 0000 0000 0000 0000 0001 0000
                                    ↑
                                  value 16
```

---

### **Step 2: Right Shift by 2 positions (`a >> 2`)**

```
Original:      0000 0000 0000 0000 0000 0000 0001 0000
               
Shift RIGHT 2: 0000 0000 0000 0000 0000 0000 0000 0100
               ↑ Filled with 0                    ↑
            (sign bit)                         value 4
```

**What happened:**
- All bits moved 2 positions to the RIGHT
- Vacated left positions filled with **sign bit** (0 for positive)
- Rightmost bits are **discarded**

---

### **Step 3: Convert back to Decimal**

```
Binary: 0000 0000 0000 0000 0000 0000 0000 0100
Decimal: 4

Proof: 16 ÷ 2² = 16 ÷ 4 = 4 ✓
```

---

## **Visual Representation:**

```
Before: 16 (binary: 10000)
        ↓ >> 2
After:  4 (binary: 100)

Position: 4 3 2 1 0
Before:   1 0 0 0 0  = 16
After:    0 0 0 1 0  = 4  (with leading zeros)
```

---

## **More Examples - Right Shift:**

### **Example 1: 20 >> 2**

```java
int x = 20;
System.out.println(x >> 2);  // 5

Binary:
20 = 0001 0100
20 >> 2 = 0000 0101 = 5
Formula: 20 ÷ 2² = 20 ÷ 4 = 5 ✓
```

---

### **Example 2: 32 >> 3**

```java
int x = 32;
System.out.println(x >> 3);  // 4

Binary:
32 = 0010 0000
32 >> 3 = 0000 0100 = 4
Formula: 32 ÷ 2³ = 32 ÷ 8 = 4 ✓
```

---

### **Example 3: 7 >> 1**

```java
int x = 7;
System.out.println(x >> 1);  // 3

Binary:
7 = 0000 0111
7 >> 1 = 0000 0011 = 3
Formula: 7 ÷ 2¹ = 7 ÷ 2 = 3 (integer division) ✓
```

---

## **With Negative Numbers:**

### **Example 4: -8 >> 2 (IMPORTANT!)**

```java
int x = -8;
System.out.println(x >> 2);  // -2
```

**Binary (2's complement for negative):**
```
-8 = 1111 1111 1111 1111 1111 1111 1111 1000

-8 >> 2 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2

Formula: -8 ÷ 2² = -8 ÷ 4 = -2 ✓
```

**Key Point:** For negative numbers, **sign bit (1) is preserved** (arithmetic right shift)

---

## **Right Shift Variations:**

### **1. Signed Right Shift (`>>`)**

- Fills with **sign bit**
- Used for signed integers
- Preserves sign

```java
20 >> 2 = 5      // Positive: fills with 0
-20 >> 2 = -5    // Negative: fills with 1 (sign extended)
```

---

### **2. Unsigned Right Shift (`>>>`)**

- Fills with **0 always**
- Used for logical shift
- Doesn't preserve sign

```java
20 >>> 2 = 5        // Same as 20 >> 2
-20 >>> 2 = 1073741819  // Different! (huge positive)
```

**Why different?**

```
-20 in binary: 1111 1111 1111 1111 1111 1111 1110 1100

-20 >> 2 (signed):   1111 1111 1111 1111 1111 1111 1111 1011 = -5
-20 >>> 2 (unsigned): 0011 1111 1111 1111 1111 1111 1111 1011 = 1073741819
```

---

## **Comparison: Left Shift vs Right Shift**

| Operation | Formula | Example | Result |
|-----------|---------|---------|--------|
| **Left Shift** | `a << n = a × 2^n` | `5 << 2` | `20` |
| **Right Shift** | `a >> n = a ÷ 2^n` | `20 >> 2` | `5` |
| **Unsigned Right** | `a >>> n = a ÷ 2^n` | `20 >>> 2` | `5` |

---

## **Complete Execution Trace:**

```java
int a = 16;
System.out.println(a >> 2);
```

**Trace:**
```
1. a = 16 (binary: 0001 0000)
2. a >> 2 (right shift by 2 positions)
3. Bits shift RIGHT by 2
4. Fill LEFT with sign bit (0)
5. Result: 0000 0100 (decimal: 4)
6. Print: 4
```

---

## **Memory/Stack Diagram:**

```
Variable: a
Value: 16
Binary: 0001 0000

Operation: a >> 2 (Right Shift by 2)

Step 1: Identify sign bit
        Sign = 0 (positive)

Step 2: Shift bits RIGHT
        0001 0000 → 0000 0100

Step 3: Fill LEFT with sign bit (0)
        0000 0100 (automatically done)

Step 4: Convert to decimal
        0000 0100 = 4

Output: 4
```

---

## **Real-World Use Cases:**

### **1. Divide by Power of 2**

```java
int x = 1024;
int result = x >> 3;  // 1024 ÷ 8 = 128
// Faster than x / 8
```

---

### **2. Extract Bits**

```java
int color = 0xFF5733;  // RGB color
int red = (color >> 16) & 0xFF;    // Extract red
int green = (color >> 8) & 0xFF;   // Extract green
int blue = color & 0xFF;            // Extract blue
```

---

### **3. Divide by 2 in Loop**

```java
int n = 64;
while(n > 0) {
    System.out.println(n);
    n = n >> 1;  // Divide by 2
}
// Output: 64, 32, 16, 8, 4, 2, 1
```

---

## **Complete Bitwise Operators Table:**

| Operator | Name | Effect | Example | Result |
|----------|------|--------|---------|--------|
| `<<` | Left Shift | Multiply by 2^n | `5 << 2` | `20` |
| `>>` | Right Shift (signed) | Divide by 2^n | `20 >> 2` | `5` |
| `>>>` | Right Shift (unsigned) | Divide by 2^n (no sign) | `20 >>> 2` | `5` |
| `&` | AND | Bitwise AND | `5 & 3` | `1` |
| `\|` | OR | Bitwise OR | `5 \| 3` | `7` |
| `^` | XOR | Bitwise XOR | `5 ^ 3` | `6` |
| `~` | NOT | Bitwise NOT | `~5` | `-6` |

---

## **Summary:**

```
Right Shift (>>):

a >> n  =  a ÷ 2^n

Example:
16 >> 2

Binary:  0001 0000  →  0000 0100
Decimal: 16         →  4
Formula: 16 ÷ 4     =  4

Output: 4 ✅
```

**Key Points:**
- ✅ Shifts bits RIGHT
- ✅ Fills LEFT with **sign bit**
- ✅ Divides by power of 2
- ✅ Faster than arithmetic division
- ⚠️ For negative numbers, sign is preserved
